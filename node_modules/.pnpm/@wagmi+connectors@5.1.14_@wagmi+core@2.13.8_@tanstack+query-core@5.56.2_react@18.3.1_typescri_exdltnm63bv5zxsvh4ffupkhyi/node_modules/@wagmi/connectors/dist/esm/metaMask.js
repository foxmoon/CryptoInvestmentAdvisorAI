import { ChainNotConfiguredError, createConnector, extractRpcUrls, } from '@wagmi/core';
import { ResourceUnavailableRpcError, SwitchChainError, UserRejectedRequestError, getAddress, hexToNumber, numberToHex, withRetry, withTimeout, } from 'viem';
metaMask.type = 'metaMask';
export function metaMask(parameters = {}) {
    let sdk;
    let provider;
    let providerPromise;
    let accountsChanged;
    let chainChanged;
    let connect;
    let displayUri;
    let disconnect;
    return createConnector((config) => ({
        id: 'metaMaskSDK',
        name: 'MetaMask',
        type: metaMask.type,
        async setup() {
            const provider = await this.getProvider();
            if (provider && !connect) {
                connect = this.onConnect.bind(this);
                provider.on('connect', connect);
            }
        },
        async connect({ chainId, isReconnecting } = {}) {
            const provider = await this.getProvider();
            if (!displayUri) {
                displayUri = this.onDisplayUri;
                provider.on('display_uri', displayUri);
            }
            let accounts = [];
            if (isReconnecting)
                accounts = await this.getAccounts().catch(() => []);
            try {
                if (!accounts?.length) {
                    const requestedAccounts = (await sdk.connect());
                    accounts = requestedAccounts.map((x) => getAddress(x));
                }
                // Switch to chain if provided
                let currentChainId = (await this.getChainId());
                if (chainId && currentChainId !== chainId) {
                    const chain = await this.switchChain({ chainId }).catch((error) => {
                        if (error.code === UserRejectedRequestError.code)
                            throw error;
                        return { id: currentChainId };
                    });
                    currentChainId = chain?.id ?? currentChainId;
                }
                if (displayUri) {
                    provider.removeListener('display_uri', displayUri);
                    displayUri = undefined;
                }
                // Manage EIP-1193 event listeners
                // https://eips.ethereum.org/EIPS/eip-1193#events
                if (connect) {
                    provider.removeListener('connect', connect);
                    connect = undefined;
                }
                if (!accountsChanged) {
                    accountsChanged = this.onAccountsChanged.bind(this);
                    provider.on('accountsChanged', accountsChanged);
                }
                if (!chainChanged) {
                    chainChanged = this.onChainChanged.bind(this);
                    provider.on('chainChanged', chainChanged);
                }
                if (!disconnect) {
                    disconnect = this.onDisconnect.bind(this);
                    provider.on('disconnect', disconnect);
                }
                return { accounts, chainId: currentChainId };
            }
            catch (err) {
                const error = err;
                if (error.code === UserRejectedRequestError.code)
                    throw new UserRejectedRequestError(error);
                if (error.code === ResourceUnavailableRpcError.code)
                    throw new ResourceUnavailableRpcError(error);
                throw error;
            }
        },
        async disconnect() {
            const provider = await this.getProvider();
            // Manage EIP-1193 event listeners
            if (accountsChanged) {
                provider.removeListener('accountsChanged', accountsChanged);
                accountsChanged = undefined;
            }
            if (chainChanged) {
                provider.removeListener('chainChanged', chainChanged);
                chainChanged = undefined;
            }
            if (disconnect) {
                provider.removeListener('disconnect', disconnect);
                disconnect = undefined;
            }
            if (!connect) {
                connect = this.onConnect.bind(this);
                provider.on('connect', connect);
            }
            await sdk.terminate();
        },
        async getAccounts() {
            const provider = await this.getProvider();
            const accounts = (await provider.request({
                method: 'eth_accounts',
            }));
            return accounts.map((x) => getAddress(x));
        },
        async getChainId() {
            const provider = await this.getProvider();
            const chainId = provider.getChainId() ||
                (await provider?.request({ method: 'eth_chainId' }));
            return Number(chainId);
        },
        async getProvider() {
            async function initProvider() {
                // Unwrapping import for Vite compatibility.
                // See: https://github.com/vitejs/vite/issues/9703
                const MetaMaskSDK = await (async () => {
                    const { default: SDK } = await import('@metamask/sdk');
                    if (typeof SDK !== 'function' && typeof SDK.default === 'function')
                        return SDK.default;
                    return SDK;
                })();
                sdk = new MetaMaskSDK({
                    _source: 'wagmi',
                    // Workaround cast since MetaMask SDK does not support `'exactOptionalPropertyTypes'`
                    ...parameters,
                    readonlyRPCMap: Object.fromEntries(config.chains.map((chain) => {
                        const [url] = extractRpcUrls({
                            chain,
                            transports: config.transports,
                        });
                        return [chain.id, url];
                    })),
                    dappMetadata: parameters.dappMetadata ?? { name: 'wagmi' },
                    useDeeplink: parameters.useDeeplink ?? true,
                });
                await sdk.init();
                return sdk.getProvider();
            }
            if (!provider) {
                if (!providerPromise)
                    providerPromise = initProvider();
                provider = await providerPromise;
            }
            return provider;
        },
        async isAuthorized() {
            try {
                // MetaMask mobile provider sometimes fails to immediately resolve
                // JSON-RPC requests on page load
                const timeout = 200;
                const accounts = await withRetry(() => withTimeout(() => this.getAccounts(), { timeout }), {
                    delay: timeout + 1,
                    retryCount: 3,
                });
                return !!accounts.length;
            }
            catch {
                return false;
            }
        },
        async switchChain({ addEthereumChainParameter, chainId }) {
            const provider = await this.getProvider();
            const chain = config.chains.find((x) => x.id === chainId);
            if (!chain)
                throw new SwitchChainError(new ChainNotConfiguredError());
            try {
                await Promise.all([
                    provider
                        .request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: numberToHex(chainId) }],
                    })
                        // During `'wallet_switchEthereumChain'`, MetaMask makes a `'net_version'` RPC call to the target chain.
                        // If this request fails, MetaMask does not emit the `'chainChanged'` event, but will still switch the chain.
                        // To counter this behavior, we request and emit the current chain ID to confirm the chain switch either via
                        // this callback or an externally emitted `'chainChanged'` event.
                        // https://github.com/MetaMask/metamask-extension/issues/24247
                        .then(async () => {
                        const currentChainId = await this.getChainId();
                        if (currentChainId === chainId)
                            config.emitter.emit('change', { chainId });
                    }),
                    new Promise((resolve) => {
                        const listener = ((data) => {
                            if ('chainId' in data && data.chainId === chainId) {
                                config.emitter.off('change', listener);
                                resolve();
                            }
                        });
                        config.emitter.on('change', listener);
                    }),
                ]);
                return chain;
            }
            catch (err) {
                const error = err;
                // Indicates chain is not added to provider
                if (error.code === 4902 ||
                    // Unwrapping for MetaMask Mobile
                    // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
                    error
                        ?.data?.originalError?.code === 4902) {
                    try {
                        const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};
                        let blockExplorerUrls;
                        if (addEthereumChainParameter?.blockExplorerUrls)
                            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
                        else if (blockExplorer)
                            blockExplorerUrls = [
                                blockExplorer.url,
                                ...Object.values(blockExplorers).map((x) => x.url),
                            ];
                        let rpcUrls;
                        if (addEthereumChainParameter?.rpcUrls?.length)
                            rpcUrls = addEthereumChainParameter.rpcUrls;
                        else
                            rpcUrls = [chain.rpcUrls.default?.http[0] ?? ''];
                        const addEthereumChain = {
                            blockExplorerUrls,
                            chainId: numberToHex(chainId),
                            chainName: addEthereumChainParameter?.chainName ?? chain.name,
                            iconUrls: addEthereumChainParameter?.iconUrls,
                            nativeCurrency: addEthereumChainParameter?.nativeCurrency ??
                                chain.nativeCurrency,
                            rpcUrls,
                        };
                        await provider.request({
                            method: 'wallet_addEthereumChain',
                            params: [addEthereumChain],
                        });
                        const currentChainId = hexToNumber(
                        // Call `'eth_chainId'` directly to guard against `this.state.chainId` (via `provider.getChainId`) being stale.
                        (await provider.request({ method: 'eth_chainId' })));
                        if (currentChainId !== chainId)
                            throw new UserRejectedRequestError(new Error('User rejected switch after adding network.'));
                        return chain;
                    }
                    catch (error) {
                        throw new UserRejectedRequestError(error);
                    }
                }
                if (error.code === UserRejectedRequestError.code)
                    throw new UserRejectedRequestError(error);
                throw new SwitchChainError(error);
            }
        },
        async onAccountsChanged(accounts) {
            // Disconnect if there are no accounts
            if (accounts.length === 0)
                this.onDisconnect();
            // Connect if emitter is listening for connect event (e.g. is disconnected and connects through wallet interface)
            else if (config.emitter.listenerCount('connect')) {
                const chainId = (await this.getChainId()).toString();
                this.onConnect({ chainId });
            }
            // Regular change event
            else
                config.emitter.emit('change', {
                    accounts: accounts.map((x) => getAddress(x)),
                });
        },
        onChainChanged(chain) {
            const chainId = Number(chain);
            config.emitter.emit('change', { chainId });
        },
        async onConnect(connectInfo) {
            const accounts = await this.getAccounts();
            if (accounts.length === 0)
                return;
            const chainId = Number(connectInfo.chainId);
            config.emitter.emit('connect', { accounts, chainId });
            const provider = await this.getProvider();
            if (connect) {
                provider.removeListener('connect', connect);
                connect = undefined;
            }
            if (!accountsChanged) {
                accountsChanged = this.onAccountsChanged.bind(this);
                provider.on('accountsChanged', accountsChanged);
            }
            if (!chainChanged) {
                chainChanged = this.onChainChanged.bind(this);
                provider.on('chainChanged', chainChanged);
            }
            if (!disconnect) {
                disconnect = this.onDisconnect.bind(this);
                provider.on('disconnect', disconnect);
            }
        },
        async onDisconnect(error) {
            const provider = await this.getProvider();
            // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting
            // https://github.com/MetaMask/providers/pull/120
            if (error && error.code === 1013) {
                if (provider && !!(await this.getAccounts()).length)
                    return;
            }
            config.emitter.emit('disconnect');
            // Manage EIP-1193 event listeners
            if (!accountsChanged) {
                accountsChanged = this.onAccountsChanged.bind(this);
                provider.on('accountsChanged', accountsChanged);
            }
            if (chainChanged) {
                provider.removeListener('chainChanged', chainChanged);
                chainChanged = undefined;
            }
            if (disconnect) {
                provider.removeListener('disconnect', disconnect);
                disconnect = undefined;
            }
            if (!connect) {
                connect = this.onConnect.bind(this);
                provider.on('connect', connect);
            }
        },
        onDisplayUri(uri) {
            config.emitter.emit('message', { type: 'display_uri', data: uri });
        },
    }));
}
//# sourceMappingURL=metaMask.js.map
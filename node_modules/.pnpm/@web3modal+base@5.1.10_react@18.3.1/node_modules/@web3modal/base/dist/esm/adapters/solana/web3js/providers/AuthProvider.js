import { ConstantsUtil } from '@web3modal/scaffold-utils';
import { ProviderEventEmitter } from './shared/ProviderEventEmitter.js';
import { PublicKey, Transaction, VersionedTransaction } from '@solana/web3.js';
import { W3mFrameProvider } from '@web3modal/wallet';
import { withSolanaNamespace } from '../utils/withSolanaNamespace.js';
import base58 from 'bs58';
import { isVersionedTransaction } from '@solana/wallet-adapter-base';
export class AuthProvider extends ProviderEventEmitter {
    constructor({ provider, getActiveChain, auth, chains }) {
        super();
        this.name = ConstantsUtil.AUTH_CONNECTOR_ID;
        this.type = 'AUTH';
        this.connectEmail = args => this.provider.connectEmail(args);
        this.connectOtp = args => this.provider.connectOtp(args);
        this.updateEmail = args => this.provider.updateEmail(args);
        this.updateEmailPrimaryOtp = args => this.provider.updateEmailPrimaryOtp(args);
        this.updateEmailSecondaryOtp = args => this.provider.updateEmailSecondaryOtp(args);
        this.getEmail = () => this.provider.getEmail();
        this.getSocialRedirectUri = args => this.provider.getSocialRedirectUri(args);
        this.connectDevice = () => this.provider.connectDevice();
        this.connectSocial = args => this.provider.connectSocial(args);
        this.connectFarcaster = () => this.provider.connectFarcaster();
        this.getFarcasterUri = () => this.provider.getFarcasterUri();
        this.syncTheme = args => this.provider.syncTheme(args);
        this.syncDappData = args => this.provider.syncDappData(args);
        this.switchNetwork = async (args) => {
            const result = await this.provider.switchNetwork(args);
            this.emit('chainChanged', args);
            return result;
        };
        this.provider = provider;
        this.getActiveChain = getActiveChain;
        this.auth = auth;
        this.requestedChains = chains;
        this.bindEvents();
    }
    get publicKey() {
        if (this.session) {
            return new PublicKey(this.session.address);
        }
        return undefined;
    }
    get chains() {
        const availableChainIds = this.provider.getAvailableChainIds();
        return this.requestedChains.filter(requestedChain => availableChainIds.includes(withSolanaNamespace(requestedChain.chainId)));
    }
    async connect() {
        this.session = await this.provider.connect({
            chainId: withSolanaNamespace(this.getActiveChain()?.chainId)
        });
        const publicKey = this.getPublicKey(true);
        this.emit('connect', publicKey);
        return publicKey.toBase58();
    }
    async disconnect() {
        await this.provider.disconnect();
        this.emit('disconnect', undefined);
    }
    async signMessage(message) {
        const result = await this.provider.request({
            method: 'solana_signMessage',
            params: { message: base58.encode(message), pubkey: this.getPublicKey(true).toBase58() }
        });
        return base58.decode(result.signature);
    }
    async signTransaction(transaction) {
        const result = await this.provider.request({
            method: 'solana_signTransaction',
            params: { transaction: this.serializeTransaction(transaction) }
        });
        const decodedTransaction = base58.decode(result.transaction);
        if (isVersionedTransaction(transaction)) {
            return VersionedTransaction.deserialize(decodedTransaction);
        }
        return Transaction.from(decodedTransaction);
    }
    async signAndSendTransaction(transaction, options) {
        const serializedTransaction = this.serializeTransaction(transaction);
        const result = await this.provider.request({
            method: 'solana_signAndSendTransaction',
            params: {
                transaction: serializedTransaction,
                options
            }
        });
        return result.signature;
    }
    async sendTransaction(transaction, connection, options) {
        const signedTransaction = await this.signTransaction(transaction);
        const signature = await connection.sendRawTransaction(signedTransaction.serialize(), options);
        return signature;
    }
    async signAllTransactions(transactions) {
        const result = await this.provider.request({
            method: 'solana_signAllTransactions',
            params: {
                transactions: transactions.map(transaction => this.serializeTransaction(transaction))
            }
        });
        return result.transactions.map((encodedTransaction, index) => {
            const transaction = transactions[index];
            if (!transaction) {
                throw new Error('Invalid solana_signAllTransactions response');
            }
            const decodedTransaction = base58.decode(encodedTransaction);
            if (isVersionedTransaction(transaction)) {
                return VersionedTransaction.deserialize(decodedTransaction);
            }
            return Transaction.from(decodedTransaction);
        });
    }
    getPublicKey(required) {
        if (!this.session) {
            if (required) {
                throw new Error('Account is required');
            }
            return undefined;
        }
        return new PublicKey(this.session.address);
    }
    serializeTransaction(transaction) {
        return base58.encode(transaction.serialize({ verifySignatures: false }));
    }
    bindEvents() {
        this.provider.onRpcRequest(request => {
            this.emit('auth_rpcRequest', request);
        });
        this.provider.onRpcSuccess(response => {
            this.emit('auth_rpcSuccess', response);
        });
        this.provider.onRpcError(error => {
            this.emit('auth_rpcError', error);
        });
        this.provider.onIsConnected(response => {
            this.session = response;
            this.emit('connect', this.getPublicKey(true));
        });
        this.provider.onNotConnected(() => {
            this.emit('disconnect', undefined);
        });
    }
}
//# sourceMappingURL=AuthProvider.js.map
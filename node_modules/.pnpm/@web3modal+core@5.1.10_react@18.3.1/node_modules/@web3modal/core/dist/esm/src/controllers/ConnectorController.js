import { subscribeKey as subKey } from 'valtio/vanilla/utils';
import { proxy, snapshot } from 'valtio/vanilla';
import { ConstantsUtil, getW3mThemeVariables } from '@web3modal/common';
import { OptionsController } from './OptionsController.js';
import { ThemeController } from './ThemeController.js';
// -- State --------------------------------------------- //
const state = proxy({
    unMergedConnectors: [],
    connectors: []
});
// -- Controller ---------------------------------------- //
export const ConnectorController = {
    state,
    subscribeKey(key, callback) {
        return subKey(state, key, callback);
    },
    setConnectors(connectors) {
        connectors.forEach(this.syncIfAuthConnector);
        state.unMergedConnectors = [...state.unMergedConnectors, ...connectors];
        state.connectors = this.mergeMultiChainConnectors(state.unMergedConnectors);
    },
    mergeMultiChainConnectors(connectors) {
        const connectorsByNameMap = this.generateConnectorMapByName(connectors);
        const refactoredConnectors = Array.from(connectorsByNameMap.values()).map(_connectors => {
            if (_connectors.length > 1) {
                return {
                    name: _connectors[0]?.name,
                    imageUrl: _connectors[0]?.imageUrl,
                    imageId: _connectors[0]?.imageId,
                    providers: this.getUniqueConnectorsByName(_connectors),
                    type: 'MULTI_CHAIN'
                };
            }
            return _connectors[0];
        });
        return refactoredConnectors;
    },
    generateConnectorMapByName(connectors) {
        const connectorsByNameMap = new Map();
        connectors.forEach(connector => {
            const { name } = connector;
            if (!name) {
                return;
            }
            const connectorsByName = connectorsByNameMap.get(name) || [];
            const haveSameConnector = connectorsByName.find(c => c.chain === connector.chain);
            if (!haveSameConnector) {
                connectorsByName.push(connector);
            }
            connectorsByNameMap.set(name, connectorsByName);
        });
        return connectorsByNameMap;
    },
    getUniqueConnectorsByName(connectors) {
        const uniqueConnectors = [];
        connectors.forEach(c => {
            if (!uniqueConnectors.find(uc => uc.chain === c.chain)) {
                uniqueConnectors.push({
                    ...c,
                    name: ConstantsUtil.CHAIN_NAME_MAP[c.chain]
                });
            }
        });
        return uniqueConnectors;
    },
    addConnector(connector) {
        this.setConnectors([connector]);
    },
    getAuthConnector() {
        return state.connectors.find(c => c.type === 'AUTH');
    },
    getAnnouncedConnectorRdns() {
        return state.connectors.filter(c => c.type === 'ANNOUNCED').map(c => c.info?.rdns);
    },
    getConnectors() {
        return state.connectors;
    },
    getConnector(id, rdns) {
        return state.connectors.find(c => c.explorerId === id || c.info?.rdns === rdns);
    },
    syncIfAuthConnector(connector) {
        if (connector.id !== 'w3mAuth') {
            return;
        }
        const authConnector = connector;
        const optionsState = snapshot(OptionsController.state);
        const themeMode = ThemeController.getSnapshot().themeMode;
        const themeVariables = ThemeController.getSnapshot().themeVariables;
        authConnector?.provider?.syncDappData?.({
            metadata: optionsState.metadata,
            sdkVersion: optionsState.sdkVersion,
            projectId: optionsState.projectId
        });
        authConnector.provider.syncTheme({
            themeMode,
            themeVariables,
            w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
        });
    }
};
//# sourceMappingURL=ConnectorController.js.map